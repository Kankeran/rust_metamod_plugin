
#ifdef __linux
#define PLATFORM "linux"
#ifdef __amd64__
#define PLATFORM_SPC "lin64"
#else
#define PLATFORM_SPC "lin32"
#endif
#elif defined(_WIN32)
#define PLATFORM "mswin"
#define PLATFORM_SPC "win32"
#elif defined(__APPLE__)
#define PLATFORM "osx"
#define PLATFORM_SPC "osx32"
#else /* unknown */
#error "OS unrecognized"
#endif /* unknown */

#undef DLLEXPORT
#ifdef _WIN32
#define DLLEXPORT __declspec(dllexport)
// WINAPI should be provided in the windows compiler headers.
// It's usually defined to something like "__stdcall".
#elif defined(__GNUC__)
#if __GNUC__ >= 4
#define DLLEXPORT __attribute__((visibility("default")))
#else
#define DLLEXPORT /* */
#endif
#define WINAPI /* */
#endif		   /* linux */

#ifdef __GNUC__
#define DECLSPEC(kw)
#define ATTRIBUTE(kw) __attribute__((kw))
#define MM_CDECL
#elif defined(_MSC_VER)
#define DECLSPEC(kw) __declspec(kw)
#define ATTRIBUTE(kw)
#define MM_CDECL __cdecl
#endif /* _MSC_VER */

#define C_DLLEXPORT extern "C" DLLEXPORT

#ifdef _MSC_VER
// Disable MSVC warning:
//    4390 : empty controlled statement found; is this what was intended?
// generated by the RETURN macros.
#pragma warning(disable : 4390)
#endif /* _MSC_VER */

#ifndef __cplusplus
typedef enum
{
	false,
	true
} qboolean;
#else
typedef int qboolean;
#endif

typedef unsigned char uint8;
typedef signed char int8;

#if defined(_WIN32)

typedef __int16 int16;
typedef unsigned __int16 uint16;
typedef __int32 int32;
typedef unsigned __int32 uint32;
typedef __int64 int64;
typedef unsigned __int64 uint64;

#ifdef X64BITS
typedef __int64 intp;			// intp is an integer that can accomodate a pointer
typedef unsigned __int64 uintp; // (ie, sizeof(intp) >= sizeof(int) && sizeof(intp) >= sizeof(void *)
#else
typedef __int32 intp;
typedef unsigned __int32 uintp;
#endif

#else // _WIN32

typedef short int16;
typedef unsigned short uint16;
typedef int int32;
typedef unsigned int uint32;
typedef long long int64;
typedef unsigned long long uint64;
#ifdef X64BITS
typedef long long intp;
typedef unsigned long long uintp;
#else
typedef int intp;
typedef unsigned int uintp;
#endif

#endif // else _WIN32

#ifdef _WIN32
typedef uint32 CRC32_t;
#else
typedef uint32 CRC32_t;
#endif

typedef struct link_s
{
	struct link_s *prev, *next;
} link_t;

#define MAX_ENT_LEAFS 48
#define ENGINE_INTERFACE_VERSION 138
#define INTERFACE_VERSION 140

typedef struct edict_s edict_t;
typedef unsigned int func_t;
typedef unsigned int string_t;
typedef float vec_t;
typedef unsigned char byte;
typedef unsigned short word;

//=========================================================
// 2DVector - used for many pathfinding and many other
// operations that are treated as planar rather than 3d.
//=========================================================
class Vector2D
{
public:
	vec_t x, y;
};

//=========================================================
// 3D Vector
//=========================================================
class Vector
{
public:
	// Members
	vec_t x, y, z;
};

#define vec3_t Vector

typedef struct
{
	float time;
	float frametime;
	float force_retouch;
	string_t mapname;
	string_t startspot;
	float deathmatch;
	float coop;
	float teamplay;
	float serverflags;
	float found_secrets;
	vec3_t v_forward;
	vec3_t v_up;
	vec3_t v_right;
	float trace_allsolid;
	float trace_startsolid;
	float trace_fraction;
	vec3_t trace_endpos;
	vec3_t trace_plane_normal;
	float trace_plane_dist;
	edict_t *trace_ent;
	float trace_inopen;
	float trace_inwater;
	int trace_hitgroup;
	int trace_flags;
	int msg_entity;
	int cdAudioTrack;
	int maxClients;
	int maxEntities;
	const char *pStringBase;

	void *pSaveData;
	vec3_t vecLandmarkOffset;
} globalvars_t;

typedef struct entvars_s
{
	string_t classname;
	string_t globalname;

	vec3_t origin;
	vec3_t oldorigin;
	vec3_t velocity;
	vec3_t basevelocity;
	vec3_t clbasevelocity; // Base velocity that was passed in to server physics so
						   //  client can predict conveyors correctly.  Server zeroes it, so we need to store here, too.
	vec3_t movedir;

	vec3_t angles;	   // Model angles
	vec3_t avelocity;  // angle velocity (degrees per second)
	vec3_t punchangle; // auto-decaying view angle adjustment
	vec3_t v_angle;	   // Viewing angle (player only)

	// For parametric entities
	vec3_t endpos;
	vec3_t startpos;
	float impacttime;
	float starttime;

	int fixangle; // 0:nothing, 1:force view angles, 2:add avelocity
	float idealpitch;
	float pitch_speed;
	float ideal_yaw;
	float yaw_speed;

	int modelindex;
	string_t model;

	int viewmodel;	 // player's viewmodel
	int weaponmodel; // what other players see

	vec3_t absmin; // BB max translated to world coord
	vec3_t absmax; // BB max translated to world coord
	vec3_t mins;   // local BB min
	vec3_t maxs;   // local BB max
	vec3_t size;   // maxs - mins

	float ltime;
	float nextthink;

	int movetype;
	int solid;

	int skin;
	int body; // sub-model selection for studiomodels
	int effects;

	float gravity;	// % of "normal" gravity
	float friction; // inverse elasticity of MOVETYPE_BOUNCE

	int light_level;

	int sequence;		// animation sequence
	int gaitsequence;	// movement animation sequence for player (0 for none)
	float frame;		// % playback position in animation sequences (0..255)
	float animtime;		// world time when frame was set
	float framerate;	// animation playback rate (-8x to 8x)
	byte controller[4]; // bone controller setting (0..255)
	byte blending[2];	// blending amount between sub-sequences (0..255)

	float scale; // sprite rendering scale (0..255)

	int rendermode;
	float renderamt;
	vec3_t rendercolor;
	int renderfx;

	float health;
	float frags;
	int weapons; // bit mask for available weapons
	float takedamage;

	int deadflag;
	vec3_t view_ofs; // eye position

	int button;
	int impulse;

	edict_t *chain; // Entity pointer when linked into a linked list
	edict_t *dmg_inflictor;
	edict_t *enemy;
	edict_t *aiment; // entity pointer when MOVETYPE_FOLLOW
	edict_t *owner;
	edict_t *groundentity;

	int spawnflags;
	int flags;

	int colormap; // lowbyte topcolor, highbyte bottomcolor
	int team;

	float max_health;
	float teleport_time;
	float armortype;
	float armorvalue;
	int waterlevel;
	int watertype;

	string_t target;
	string_t targetname;
	string_t netname;
	string_t message;

	float dmg_take;
	float dmg_save;
	float dmg;
	float dmgtime;

	string_t noise;
	string_t noise1;
	string_t noise2;
	string_t noise3;

	float speed;
	float air_finished;
	float pain_finished;
	float radsuit_finished;

	edict_t *pContainingEntity;

	int playerclass;
	float maxspeed;

	float fov;
	int weaponanim;

	int pushmsec;

	int bInDuck;
	int flTimeStepSound;
	int flSwimTime;
	int flDuckTime;
	int iStepLeft;
	float flFallVelocity;

	int gamestate;

	int oldbuttons;

	int groupinfo;

	// For mods
	int iuser1;
	int iuser2;
	int iuser3;
	int iuser4;
	float fuser1;
	float fuser2;
	float fuser3;
	float fuser4;
	vec3_t vuser1;
	vec3_t vuser2;
	vec3_t vuser3;
	vec3_t vuser4;
	edict_t *euser1;
	edict_t *euser2;
	edict_t *euser3;
	edict_t *euser4;
} entvars_t;

struct edict_s
{
	qboolean free;
	int serialnumber;
	link_t area;  // linked to a division node or leaf
	int headnode; // -1 to use normal leaf check
	int num_leafs;
	short leafnums[MAX_ENT_LEAFS];
	float freetime;		 // sv.time when the object was freed
	void *pvPrivateData; // Alloced and freed by engine, used by DLLs
	entvars_t v;		 // C exported fields from progs
						 // other fields from progs come immediately after
};

typedef struct
{
	int fAllSolid;	 // if true, plane is not valid
	int fStartSolid; // if true, the initial point was in a solid area
	int fInOpen;
	int fInWater;
	float flFraction; // time completed, 1.0 = didn't hit anything
	vec3_t vecEndPos; // final position
	float flPlaneDist;
	vec3_t vecPlaneNormal; // surface normal at impact
	edict_t *pHit;		   // entity the surface is on
	int iHitgroup;		   // 0 == generic, non zero is specific body part
} TraceResult;

typedef struct cvar_s
{
	const char *name;
	const char *string;
	int flags;
	float value;
	struct cvar_s *next;
} cvar_t;

typedef enum
{
	at_notice,
	at_console,	  // same as at_notice, but forces a ConPrintf, not a message box
	at_aiconsole, // same as at_console, but only shown if developer level is 2!
	at_warning,
	at_error,
	at_logged // Server print to console ( only in multiplayer games ).
} ALERT_TYPE;

typedef enum
{
	print_console,
	print_center,
	print_chat,
} PRINT_TYPE;

typedef enum
{
	force_exactfile,					// File on client must exactly match server's file
	force_model_samebounds,				// For model files only, the geometry must fit in the same bbox
	force_model_specifybounds,			// For model files only, the geometry must fit in the specified bbox
	force_model_specifybounds_if_avail, // For Steam model files only, the geometry must fit in the specified bbox (if the file is available)
} FORCE_TYPE;

typedef struct sentenceEntry_ sentenceEntry_s;
struct sentenceEntry_
{
	char *data;					// sentence data (ie "We have hostiles" )
	sentenceEntry_s *nextEntry; // Next loaded entry
	qboolean isGlobal;			// Is entry retained over level transitions?
	unsigned int index;			// this entry's position in the file.
};

typedef struct client_textmessage_s
{
	int effect;
	byte r1, g1, b1, a1; // 2 colors for effects
	byte r2, g2, b2, a2;
	float x;
	float y;
	float fadein;
	float fadeout;
	float holdtime;
	float fxtime;
	const char *pName;
	const char *pMessage;
} client_textmessage_t;

typedef struct sequenceCommandLine_ sequenceCommandLine_s;
struct sequenceCommandLine_
{
	int commandType;						// Specifies the type of command
	client_textmessage_t clientMessage;		// Text HUD message struct
	char *speakerName;						// Targetname of speaking entity
	char *listenerName;						// Targetname of entity being spoken to
	char *soundFileName;					// Name of sound file to play
	char *sentenceName;						// Name of sentences.txt to play
	char *fireTargetNames;					// List of targetnames to fire
	char *killTargetNames;					// List of targetnames to remove
	float delay;							// Seconds 'till next command
	int repeatCount;						// If nonzero, reset execution pointer to top of block (N times, -1 = infinite)
	int textChannel;						// Display channel on which text message is sent
	int modifierBitField;					// Bit field to specify what clientmessage fields are valid
	sequenceCommandLine_s *nextCommandLine; // Next command (linked list)
};

typedef struct sequenceEntry_ sequenceEntry_s;
struct sequenceEntry_
{
	char *fileName;						 // Name of sequence file without .SEQ extension
	char *entryName;					 // Name of entry label in file
	sequenceCommandLine_s *firstCommand; // Linked list of commands in entry
	sequenceEntry_s *nextEntry;			 // Next loaded entry
	qboolean isGlobal;					 // Is entry retained over level transitions?
};

typedef struct enginefuncs_s
{
	int (*pfnPrecacheModel)(const char *s);
	int (*pfnPrecacheSound)(const char *s);
	void (*pfnSetModel)(edict_t *e, const char *m);
	int (*pfnModelIndex)(const char *m);
	int (*pfnModelFrames)(int modelIndex);
	void (*pfnSetSize)(edict_t *e, const float *rgflMin, const float *rgflMax);
	void (*pfnChangeLevel)(const char *s1, const char *s2);
	void (*pfnGetSpawnParms)(edict_t *ent);
	void (*pfnSaveSpawnParms)(edict_t *ent);
	float (*pfnVecToYaw)(const float *rgflVector);
	void (*pfnVecToAngles)(const float *rgflVectorIn, float *rgflVectorOut);
	void (*pfnMoveToOrigin)(edict_t *ent, const float *pflGoal, float dist, int iMoveType);
	void (*pfnChangeYaw)(edict_t *ent);
	void (*pfnChangePitch)(edict_t *ent);
	edict_t *(*pfnFindEntityByString)(edict_t *pEdictStartSearchAfter, const char *pszField, const char *pszValue);
	int (*pfnGetEntityIllum)(edict_t *pEnt);
	edict_t *(*pfnFindEntityInSphere)(edict_t *pEdictStartSearchAfter, const float *org, float rad);
	edict_t *(*pfnFindClientInPVS)(edict_t *pEdict);
	edict_t *(*pfnEntitiesInPVS)(edict_t *pplayer);
	void (*pfnMakeVectors)(const float *rgflVector);
	void (*pfnAngleVectors)(const float *rgflVector, float *forward, float *right, float *up);
	edict_t *(*pfnCreateEntity)(void);
	void (*pfnRemoveEntity)(edict_t *e);
	edict_t *(*pfnCreateNamedEntity)(int className);
	void (*pfnMakeStatic)(edict_t *ent);
	int (*pfnEntIsOnFloor)(edict_t *e);
	int (*pfnDropToFloor)(edict_t *e);
	int (*pfnWalkMove)(edict_t *ent, float yaw, float dist, int iMode);
	void (*pfnSetOrigin)(edict_t *e, const float *rgflOrigin);
	void (*pfnEmitSound)(edict_t *entity, int channel, const char *sample, /*int*/ float volume, float attenuation, int fFlags, int pitch);
	void (*pfnEmitAmbientSound)(edict_t *entity, float *pos, const char *samp, float vol, float attenuation, int fFlags, int pitch);
	void (*pfnTraceLine)(const float *v1, const float *v2, int fNoMonsters, edict_t *pentToSkip, TraceResult *ptr);
	void (*pfnTraceToss)(edict_t *pent, edict_t *pentToIgnore, TraceResult *ptr);
	int (*pfnTraceMonsterHull)(edict_t *pEdict, const float *v1, const float *v2, int fNoMonsters, edict_t *pentToSkip, TraceResult *ptr);
	void (*pfnTraceHull)(const float *v1, const float *v2, int fNoMonsters, int hullNumber, edict_t *pentToSkip, TraceResult *ptr);
	void (*pfnTraceModel)(const float *v1, const float *v2, int hullNumber, edict_t *pent, TraceResult *ptr);
	const char *(*pfnTraceTexture)(edict_t *pTextureEntity, const float *v1, const float *v2);
	void (*pfnTraceSphere)(const float *v1, const float *v2, int fNoMonsters, float radius, edict_t *pentToSkip, TraceResult *ptr);
	void (*pfnGetAimVector)(edict_t *ent, float speed, float *rgflReturn);
	void (*pfnServerCommand)(const char *str);
	void (*pfnServerExecute)(void);
	void (*pfnClientCommand)(edict_t *pEdict, const char *szFmt, ...);
	void (*pfnParticleEffect)(const float *org, const float *dir, float color, float count);
	void (*pfnLightStyle)(int style, const char *val);
	int (*pfnDecalIndex)(const char *name);
	int (*pfnPointContents)(const float *rgflVector);
	void (*pfnMessageBegin)(int msg_dest, int msg_type, const float *pOrigin, edict_t *ed);
	void (*pfnMessageEnd)(void);
	void (*pfnWriteByte)(int iValue);
	void (*pfnWriteChar)(int iValue);
	void (*pfnWriteShort)(int iValue);
	void (*pfnWriteLong)(int iValue);
	void (*pfnWriteAngle)(float flValue);
	void (*pfnWriteCoord)(float flValue);
	void (*pfnWriteString)(const char *sz);
	void (*pfnWriteEntity)(int iValue);
	void (*pfnCVarRegister)(cvar_t *pCvar);
	float (*pfnCVarGetFloat)(const char *szVarName);
	const char *(*pfnCVarGetString)(const char *szVarName);
	void (*pfnCVarSetFloat)(const char *szVarName, float flValue);
	void (*pfnCVarSetString)(const char *szVarName, const char *szValue);
	void (*pfnAlertMessage)(ALERT_TYPE atype, const char *szFmt, ...);
	void (*pfnEngineFprintf)(void *pfile, const char *szFmt, ...);
	void *(*pfnPvAllocEntPrivateData)(edict_t *pEdict, int32 cb);
	void *(*pfnPvEntPrivateData)(edict_t *pEdict);
	void (*pfnFreeEntPrivateData)(edict_t *pEdict);
	const char *(*pfnSzFromIndex)(int iString);
	int (*pfnAllocString)(const char *szValue);
	struct entvars_s *(*pfnGetVarsOfEnt)(edict_t *pEdict);
	edict_t *(*pfnPEntityOfEntOffset)(int iEntOffset);
	int (*pfnEntOffsetOfPEntity)(const edict_t *pEdict);
	int (*pfnIndexOfEdict)(const edict_t *pEdict);
	edict_t *(*pfnPEntityOfEntIndex)(int iEntIndex);
	edict_t *(*pfnFindEntityByVars)(struct entvars_s *pvars);
	void *(*pfnGetModelPtr)(edict_t *pEdict);
	int (*pfnRegUserMsg)(const char *pszName, int iSize);
	void (*pfnAnimationAutomove)(const edict_t *pEdict, float flTime);
	void (*pfnGetBonePosition)(const edict_t *pEdict, int iBone, float *rgflOrigin, float *rgflAngles);
	uint32 (*pfnFunctionFromName)(const char *pName);
	const char *(*pfnNameForFunction)(uint32 function);
	void (*pfnClientPrintf)(edict_t *pEdict, PRINT_TYPE ptype, const char *szMsg); // JOHN: engine callbacks so game DLL can print messages to individual clients
	void (*pfnServerPrint)(const char *szMsg);
	const char *(*pfnCmd_Args)(void);	  // these 3 added
	const char *(*pfnCmd_Argv)(int argc); // so game DLL can easily
	int (*pfnCmd_Argc)(void);			  // access client 'cmd' strings
	void (*pfnGetAttachment)(const edict_t *pEdict, int iAttachment, float *rgflOrigin, float *rgflAngles);
	void (*pfnCRC32_Init)(CRC32_t *pulCRC);
	void (*pfnCRC32_ProcessBuffer)(CRC32_t *pulCRC, void *p, int len);
	void (*pfnCRC32_ProcessByte)(CRC32_t *pulCRC, unsigned char ch);
	CRC32_t (*pfnCRC32_Final)(CRC32_t pulCRC);
	int32 (*pfnRandomLong)(int32 lLow, int32 lHigh);
	float (*pfnRandomFloat)(float flLow, float flHigh);
	void (*pfnSetView)(const edict_t *pClient, const edict_t *pViewent);
	float (*pfnTime)(void);
	void (*pfnCrosshairAngle)(const edict_t *pClient, float pitch, float yaw);
	byte *(*pfnLoadFileForMe)(const char *filename, int *pLength);
	void (*pfnFreeFile)(void *buffer);
	void (*pfnEndSection)(const char *pszSectionName); // trigger_endsection
	int (*pfnCompareFileTime)(char *filename1, char *filename2, int *iCompare);
	void (*pfnGetGameDir)(char *szGetGameDir);
	void (*pfnCvar_RegisterVariable)(cvar_t *variable);
	void (*pfnFadeClientVolume)(const edict_t *pEdict, int fadePercent, int fadeOutSeconds, int holdTime, int fadeInSeconds);
	void (*pfnSetClientMaxspeed)(const edict_t *pEdict, float fNewMaxspeed);
	edict_t *(*pfnCreateFakeClient)(const char *netname); // returns NULL if fake client can't be created
	void (*pfnRunPlayerMove)(edict_t *fakeclient, const float *viewangles, float forwardmove, float sidemove, float upmove, unsigned short buttons, byte impulse, byte msec);
	int (*pfnNumberOfEntities)(void);
	char *(*pfnGetInfoKeyBuffer)(edict_t *e); // passing in NULL gets the serverinfo
	char *(*pfnInfoKeyValue)(char *infobuffer, const char *key);
	void (*pfnSetKeyValue)(char *infobuffer, const char *key, const char *value);
	void (*pfnSetClientKeyValue)(int clientIndex, char *infobuffer, const char *key, const char *value);
	int (*pfnIsMapValid)(const char *filename);
	void (*pfnStaticDecal)(const float *origin, int decalIndex, int entityIndex, int modelIndex);
	int (*pfnPrecacheGeneric)(const char *s);
	int (*pfnGetPlayerUserId)(edict_t *e); // returns the server assigned userid for this player.  useful for logging frags, etc.  returns -1 if the edict couldn't be found in the list of clients
	void (*pfnBuildSoundMsg)(edict_t *entity, int channel, const char *sample, /*int*/ float volume, float attenuation, int fFlags, int pitch, int msg_dest, int msg_type, const float *pOrigin, edict_t *ed);
	int (*pfnIsDedicatedServer)(void); // is this a dedicated server?
	cvar_t *(*pfnCVarGetPointer)(const char *szVarName);
	unsigned int (*pfnGetPlayerWONId)(edict_t *e); // returns the server assigned WONid for this player.  useful for logging frags, etc.  returns -1 if the edict couldn't be found in the list of clients

	// YWB 8/1/99 TFF Physics additions
	void (*pfnInfo_RemoveKey)(char *s, const char *key);
	const char *(*pfnGetPhysicsKeyValue)(const edict_t *pClient, const char *key);
	void (*pfnSetPhysicsKeyValue)(const edict_t *pClient, const char *key, const char *value);
	const char *(*pfnGetPhysicsInfoString)(const edict_t *pClient);
	unsigned short (*pfnPrecacheEvent)(int type, const char *psz);
	void (*pfnPlaybackEvent)(int flags, const edict_t *pInvoker, unsigned short eventindex, float delay, float *origin, float *angles, float fparam1, float fparam2, int iparam1, int iparam2, int bparam1, int bparam2);

	unsigned char *(*pfnSetFatPVS)(float *org);
	unsigned char *(*pfnSetFatPAS)(float *org);

	int (*pfnCheckVisibility)(const edict_t *entity, unsigned char *pset);

	void (*pfnDeltaSetField)(struct delta_s *pFields, const char *fieldname);
	void (*pfnDeltaUnsetField)(struct delta_s *pFields, const char *fieldname);
	void (*pfnDeltaAddEncoder)(const char *name, void (*conditionalencode)(struct delta_s *pFields, const unsigned char *from, const unsigned char *to));
	int (*pfnGetCurrentPlayer)(void);
	int (*pfnCanSkipPlayer)(const edict_t *player);
	int (*pfnDeltaFindField)(struct delta_s *pFields, const char *fieldname);
	void (*pfnDeltaSetFieldByIndex)(struct delta_s *pFields, int fieldNumber);
	void (*pfnDeltaUnsetFieldByIndex)(struct delta_s *pFields, int fieldNumber);

	void (*pfnSetGroupMask)(int mask, int op);

	int (*pfnCreateInstancedBaseline)(int classname, struct entity_state_s *baseline);
	void (*pfnCvar_DirectSet)(struct cvar_s *var, const char *value);

	// Forces the client and server to be running with the same version of the specified file
	//  ( e.g., a player model ).
	// Calling this has no effect in single player
	void (*pfnForceUnmodified)(FORCE_TYPE type, float *mins, float *maxs, const char *filename);

	void (*pfnGetPlayerStats)(const edict_t *pClient, int *ping, int *packet_loss);

	void (*pfnAddServerCommand)(const char *cmd_name, void (*function)(void));

	// For voice communications, set which clients hear eachother.
	// NOTE: these functions take player entity indices (starting at 1).
	qboolean (*pfnVoice_GetClientListening)(int iReceiver, int iSender);
	qboolean (*pfnVoice_SetClientListening)(int iReceiver, int iSender, qboolean bListen);

	const char *(*pfnGetPlayerAuthId)(edict_t *e);

	// PSV: Added for CZ training map
	//	const char *(*pfnKeyNameForBinding)					( const char* pBinding );

	sequenceEntry_s *(*pfnSequenceGet)(const char *fileName, const char *entryName);
	sentenceEntry_s *(*pfnSequencePickSentence)(const char *groupName, int pickMethod, int *picked);

	// LH: Give access to filesize via filesystem
	int (*pfnGetFileSize)(const char *filename);

	unsigned int (*pfnGetApproxWavePlayLen)(const char *filepath);
	// MDC: Added for CZ career-mode
	int (*pfnIsCareerMatch)(void);

	// BGC: return the number of characters of the localized string referenced by using "label"
	int (*pfnGetLocalizedStringLength)(const char *label);

	// BGC: added to facilitate persistent storage of tutor message decay values for
	// different career game profiles.  Also needs to persist regardless of mp.dll being
	// destroyed and recreated.
	void (*pfnRegisterTutorMessageShown)(int mid);
	int (*pfnGetTimesTutorMessageShown)(int mid);
	void (*pfnProcessTutorMessageDecayBuffer)(int *buffer, int bufferLength);
	void (*pfnConstructTutorMessageDecayBuffer)(int *buffer, int bufferLength);
	void (*pfnResetTutorMessageDecayData)(void);
	void (*pfnQueryClientCvarValue)(const edict_t *player, const char *cvarName);
	void (*pfnQueryClientCvarValue2)(const edict_t *player, const char *cvarName, int requestID);
	int (*pfnCheckParm)(const char *pchCmdLineToken, char **ppnext);
} enginefuncs_t;

typedef enum
{
	PT_NEVER = 0,
	PT_STARTUP,		// should only be loaded/unloaded at initial hlds execution
	PT_CHANGELEVEL, // can be loaded/unloaded between maps
	PT_ANYTIME,		// can be loaded/unloaded at any time
	PT_ANYPAUSE,	// can be loaded/unloaded at any time, and can be "paused" during a map
} PLUG_LOADTIME;

typedef enum
{
	PNL_NULL = 0,
	PNL_INI_DELETED, // was deleted from plugins.ini
	PNL_FILE_NEWER,	 // file on disk is newer than last load
	PNL_COMMAND,	 // requested by server/console command
	PNL_CMD_FORCED,	 // forced by server/console command
	PNL_DELAYED,	 // delayed from previous request; can't tell origin
					 // only used for 'real_reason' on MPlugin::unload()
	PNL_PLUGIN,		 // requested by plugin function call
	PNL_PLG_FORCED,	 // forced by plugin function call
	PNL_RELOAD,		 // forced unload by reload()
} PL_UNLOAD_REASON;

typedef struct
{
	const char *ifvers;		  // meta_interface version
	const char *name;		  // full name of plugin
	const char *version;	  // version
	const char *date;		  // date
	const char *author;		  // author name/email
	const char *url;		  // URL
	const char *logtag;		  // log message prefix (unused right now)
	PLUG_LOADTIME loadable;	  // when loadable
	PLUG_LOADTIME unloadable; // when unloadable
} plugin_info_t;
typedef plugin_info_t *plid_t;

typedef struct hudtextparms_s
{
	float x;
	float y;
	int effect;
	byte r1, g1, b1, a1;
	byte r2, g2, b2, a2;
	float fadeinTime;
	float fadeoutTime;
	float holdTime;
	float fxTime;
	int channel;
} hudtextparms_t;

typedef char *va_list;

typedef enum
{
	GINFO_NAME = 0,
	GINFO_DESC,
	GINFO_GAMEDIR,
	GINFO_DLL_FULLPATH,
	GINFO_DLL_FILENAME,
	GINFO_REALDLL_FULLPATH,
} ginfo_t;

typedef struct KeyValueData_s
{
	const char *szClassName; // in: entity classname
	const char *szKeyName;	 // in: name of key
	const char *szValue;	 // in: value of key
	int32 fHandled;			 // out: DLL sets to true if key-value pair was understood
} KeyValueData;

typedef struct saverestore_s SAVERESTOREDATA;

typedef struct
{
	int id;		   // Ordinal ID of this entity (used for entity <--> pointer conversions)
	edict_t *pent; // Pointer to the in-game entity

	int location;		// Offset from the base data of this entity
	int size;			// Byte size of this entity's data
	int flags;			// This could be a short -- bit mask of transitions that this entity is in the PVS of
	string_t classname; // entity class name

} ENTITYTABLE;

typedef struct
{
	char mapName[32];
	char landmarkName[32];
	edict_t *pentLandmark;
	vec3_t vecLandmarkOrigin;
} LEVELLIST;
#define MAX_LEVEL_CONNECTIONS 16

struct saverestore_s
{
	char *pBaseData;							// Start of all entity save data
	char *pCurrentData;							// Current buffer pointer for sequential access
	int size;									// Current data size
	int bufferSize;								// Total space for data
	int tokenSize;								// Size of the linear list of tokens
	int tokenCount;								// Number of elements in the pTokens table
	char **pTokens;								// Hash table of entity strings (sparse)
	int currentIndex;							// Holds a global entity table ID
	int tableCount;								// Number of elements in the entity table
	int connectionCount;						// Number of elements in the levelList[]
	ENTITYTABLE *pTable;						// Array of ENTITYTABLE elements (1 for each entity)
	LEVELLIST levelList[MAX_LEVEL_CONNECTIONS]; // List of connections from this level

	// smooth transition
	int fUseLandmark;
	char szLandmarkName[20];  // landmark we'll spawn near in next level
	vec3_t vecLandmarkOffset; // for landmark transitions
	float time;
	char szCurrentMapName[32]; // To check global entities
};

typedef enum _fieldtypes
{
	FIELD_FLOAT = 0,	   // Any floating point value
	FIELD_STRING,		   // A string ID (return from ALLOC_STRING)
	FIELD_ENTITY,		   // An entity offset (EOFFSET)
	FIELD_CLASSPTR,		   // CBaseEntity *
	FIELD_EHANDLE,		   // Entity handle
	FIELD_EVARS,		   // EVARS *
	FIELD_EDICT,		   // edict_t *, or edict_t *  (same thing)
	FIELD_VECTOR,		   // Any vector
	FIELD_POSITION_VECTOR, // A world coordinate (these are fixed up across level transitions automagically)
	FIELD_POINTER,		   // Arbitrary data pointer... to be removed, use an array of FIELD_CHARACTER
	FIELD_INTEGER,		   // Any integer or enum
	FIELD_FUNCTION,		   // A class function pointer (Think, Use, etc)
	FIELD_BOOLEAN,		   // boolean, implemented as an int, I may use this as a hint for compression
	FIELD_SHORT,		   // 2 byte integer
	FIELD_CHARACTER,	   // a byte
	FIELD_TIME,			   // a floating point time (these are fixed up automatically too!)
	FIELD_MODELNAME,	   // Engine string that is a model name (needs precache)
	FIELD_SOUNDNAME,	   // Engine string that is a sound name (needs precache)

	FIELD_TYPECOUNT, // MUST BE LAST
} FIELDTYPE;

typedef struct
{
	FIELDTYPE fieldType;
	const char *fieldName;
	int fieldOffset;
	short fieldSize;
	short flags;
} TYPEDESCRIPTION;

typedef enum
{
	t_sound = 0,
	t_skin,
	t_model,
	t_decal,
	t_generic,
	t_eventscript,
	t_world, // Fake type for world, is really t_model
} resourcetype_t;

#define MAX_QPATH 64

typedef struct resource_s
{
	char szFileName[MAX_QPATH]; // File name to download/precache.
	resourcetype_t type;		// t_sound, t_skin, t_model, t_decal.
	int nIndex;					// For t_decals
	int nDownloadSize;			// Size in Bytes if this must be downloaded.
	unsigned char ucFlags;

	// For handling client to client resource propagation
	unsigned char rgucMD5_hash[16]; // To determine if we already have it.
	unsigned char playernum;		// Which player index this resource is associated with, if it's a custom resource.

	unsigned char rguc_reserved[32]; // For future expansion
	struct resource_s *pNext;		 // Next in chain.
	struct resource_s *pPrev;
} resource_t;

typedef struct customization_s
{
	qboolean bInUse;			   // Is this customization in use;
	resource_t resource;		   // The resource_t for this customization
	qboolean bTranslated;		   // Has the raw data been translated into a useable format?
								   //  (e.g., raw decal .wad make into texture_t *)
	int nUserData1;				   // Customization specific data
	int nUserData2;				   // Customization specific data
	void *pInfo;				   // Buffer that holds the data structure that references the data (e.g., the cachewad_t)
	void *pBuffer;				   // Buffer that holds the data for the customization (the raw .wad data)
	struct customization_s *pNext; // Next in chain
} customization_t;

typedef struct
{
	// Initialize/shutdown the game (one-time call after loading of game .dll )
	void (*pfnGameInit)(void);
	int (*pfnSpawn)(edict_t *pent);
	void (*pfnThink)(edict_t *pent);
	void (*pfnUse)(edict_t *pentUsed, edict_t *pentOther);
	void (*pfnTouch)(edict_t *pentTouched, edict_t *pentOther);
	void (*pfnBlocked)(edict_t *pentBlocked, edict_t *pentOther);
	void (*pfnKeyValue)(edict_t *pentKeyvalue, KeyValueData *pkvd);
	void (*pfnSave)(edict_t *pent, SAVERESTOREDATA *pSaveData);
	int (*pfnRestore)(edict_t *pent, SAVERESTOREDATA *pSaveData, int globalEntity);
	void (*pfnSetAbsBox)(edict_t *pent);

	void (*pfnSaveWriteFields)(SAVERESTOREDATA *, const char *, void *, TYPEDESCRIPTION *, int);
	void (*pfnSaveReadFields)(SAVERESTOREDATA *, const char *, void *, TYPEDESCRIPTION *, int);

	void (*pfnSaveGlobalState)(SAVERESTOREDATA *);
	void (*pfnRestoreGlobalState)(SAVERESTOREDATA *);
	void (*pfnResetGlobalState)(void);

	qboolean (*pfnClientConnect)(edict_t *pEntity, const char *pszName, const char *pszAddress, char szRejectReason[128]);

	void (*pfnClientDisconnect)(edict_t *pEntity);
	void (*pfnClientKill)(edict_t *pEntity);
	void (*pfnClientPutInServer)(edict_t *pEntity);
	void (*pfnClientCommand)(edict_t *pEntity);
	void (*pfnClientUserInfoChanged)(edict_t *pEntity, char *infobuffer);

	void (*pfnServerActivate)(edict_t *pEdictList, int edictCount, int clientMax);
	void (*pfnServerDeactivate)(void);

	void (*pfnPlayerPreThink)(edict_t *pEntity);
	void (*pfnPlayerPostThink)(edict_t *pEntity);

	void (*pfnStartFrame)(void);
	void (*pfnParmsNewLevel)(void);
	void (*pfnParmsChangeLevel)(void);

	// Returns string describing current .dll.  E.g., TeamFotrress 2, Half-Life
	const char *(*pfnGetGameDescription)(void);

	// Notify dll about a player customization.
	void (*pfnPlayerCustomization)(edict_t *pEntity, customization_t *pCustom);

	// Spectator funcs
	void (*pfnSpectatorConnect)(edict_t *pEntity);
	void (*pfnSpectatorDisconnect)(edict_t *pEntity);
	void (*pfnSpectatorThink)(edict_t *pEntity);

	// Notify game .dll that engine is going to shut down.  Allows mod authors to set a breakpoint.
	void (*pfnSys_Error)(const char *error_string);

	void (*pfnPM_Move)(struct playermove_s *ppmove, qboolean server);
	void (*pfnPM_Init)(struct playermove_s *ppmove);
	char (*pfnPM_FindTextureType)(const char *name);
	void (*pfnSetupVisibility)(struct edict_s *pViewEntity, struct edict_s *pClient, unsigned char **pvs, unsigned char **pas);
	void (*pfnUpdateClientData)(const struct edict_s *ent, int sendweapons, struct clientdata_s *cd);
	int (*pfnAddToFullPack)(struct entity_state_s *state, int e, edict_t *ent, edict_t *host, int hostflags, int player, unsigned char *pSet);
	void (*pfnCreateBaseline)(int player, int eindex, struct entity_state_s *baseline, struct edict_s *entity, int playermodelindex, vec3_t player_mins, vec3_t player_maxs);
	void (*pfnRegisterEncoders)(void);
	int (*pfnGetWeaponData)(struct edict_s *player, struct weapon_data_s *info);

	void (*pfnCmdStart)(const edict_t *player, const struct usercmd_s *cmd, unsigned int random_seed);
	void (*pfnCmdEnd)(const edict_t *player);

	// Return 1 if the packet is valid.  Set response_buffer_size if you want to send a response packet.  Incoming, it holds the max
	//  size of the response_buffer, so you must zero it out if you choose not to respond.
	int (*pfnConnectionlessPacket)(const struct netadr_s *net_from, const char *args, char *response_buffer, int *response_buffer_size);

	// Enumerates player hulls.  Returns 0 if the hull number doesn't exist, 1 otherwise
	int (*pfnGetHullBounds)(int hullnumber, float *mins, float *maxs);

	// Create baselines for certain "unplaced" items.
	void (*pfnCreateInstancedBaselines)(void);

	// One of the pfnForceUnmodified files failed the consistency check for the specified player
	// Return 0 to allow the client to continue, 1 to force immediate disconnection ( with an optional disconnect message of up to 256 characters )
	int (*pfnInconsistentFile)(const struct edict_s *player, const char *filename, char *disconnect_message);

	// The game .dll should return 1 if lag compensation should be allowed ( could also just set
	//  the sv_unlag cvar.
	// Most games right now should return 0, until client-side weapon prediction code is written
	//  and tested for them.
	int (*pfnAllowLagCompensation)(void);
} DLL_FUNCTIONS;

typedef struct
{
	// Called right before the object's memory is freed.
	// Calls its destructor.
	void (*pfnOnFreeEntPrivateData)(edict_t *pEnt);
	void (*pfnGameShutdown)(void);
	int (*pfnShouldCollide)(edict_t *pentTouched, edict_t *pentOther);
	void (*pfnCvarValue)(const edict_t *pEnt, const char *value);
	void (*pfnCvarValue2)(const edict_t *pEnt, int requestID, const char *cvarName, const char *value);
} NEW_DLL_FUNCTIONS;

typedef struct meta_util_funcs_s
{
	void (*pfnLogConsole)(plid_t plid, const char *fmt, ...);
	void (*pfnLogMessage)(plid_t plid, const char *fmt, ...);
	void (*pfnLogError)(plid_t plid, const char *fmt, ...);
	void (*pfnLogDeveloper)(plid_t plid, const char *fmt, ...);
	void (*pfnCenterSay)(plid_t plid, const char *fmt, ...);
	void (*pfnCenterSayParms)(plid_t plid, hudtextparms_t tparms,
							  const char *fmt, ...);
	void (*pfnCenterSayVarargs)(plid_t plid, hudtextparms_t tparms,
								const char *fmt, va_list ap);
	qboolean (*pfnCallGameEntity)(plid_t plid, const char *entStr,
								  entvars_t *pev);
	int (*pfnGetUserMsgID)(plid_t plid, const char *msgname, int *size);
	const char *(*pfnGetUserMsgName)(plid_t plid, int msgid, int *size);
	const char *(*pfnGetPluginPath)(plid_t plid);
	const char *(*pfnGetGameInfo)(plid_t plid, ginfo_t tag);
	int (*pfnLoadPlugin)(plid_t plid, const char *cmdline, PLUG_LOADTIME now, void **plugin_handle);
	int (*pfnUnloadPlugin)(plid_t plid, const char *cmdline, PLUG_LOADTIME now, PL_UNLOAD_REASON reason);
	int (*pfnUnloadPluginByHandle)(plid_t plid, void *plugin_handle, PLUG_LOADTIME now, PL_UNLOAD_REASON reason);
	const char *(*pfnIsQueryingClientCvar)(plid_t plid, const edict_t *pEdict);
	int (*pfnMakeRequestId)(plid_t plid);
	void (*pfnGetHookTables)(plid_t plid, enginefuncs_t **peng, DLL_FUNCTIONS **pdll, NEW_DLL_FUNCTIONS **pnewdll);
#ifdef UNFINISHED
	int (*pfnHookGameEvent)(plid_t plid, game_event_t event,
							event_func_t pfnHandle);
	int (*pfnHookLogTrigger)(plid_t plid, const char *trigger,
							 logmatch_func_t pfnHandle);
	int (*pfnHookLogString)(plid_t plid, const char *string,
							logmatch_func_t pfnHandle);
	int (*pfnHookLogRegex)(plid_t plid, const char *pattern,
						   logmatch_func_t pfnHandle);
	qboolean (*pfnRemoveHookID)(plid_t plid, int hookid);
	int (*pfnRemoveHookAll)(plid_t plid);
#endif /* UNFINISHED */
} mutil_funcs_t;

typedef int (*GETENTITYAPI_FN)(DLL_FUNCTIONS *pFunctionTable, int interfaceVersion);
typedef int (*GETENTITYAPI2_FN)(DLL_FUNCTIONS *pFunctionTable, int *interfaceVersion);
typedef int (*GETNEWDLLFUNCTIONS_FN)(NEW_DLL_FUNCTIONS *pFunctionTable, int *interfaceVersion);
typedef int (*GET_ENGINE_FUNCTIONS_FN)(enginefuncs_t *pengfuncsFromEngine, int *interfaceVersion);

typedef struct
{
	GETENTITYAPI_FN pfnGetEntityAPI;
	GETENTITYAPI_FN pfnGetEntityAPI_Post;
	GETENTITYAPI2_FN pfnGetEntityAPI2;
	GETENTITYAPI2_FN pfnGetEntityAPI2_Post;
	GETNEWDLLFUNCTIONS_FN pfnGetNewDLLFunctions;
	GETNEWDLLFUNCTIONS_FN pfnGetNewDLLFunctions_Post;
	GET_ENGINE_FUNCTIONS_FN pfnGetEngineFunctions;
	GET_ENGINE_FUNCTIONS_FN pfnGetEngineFunctions_Post;
} META_FUNCTIONS;

typedef enum
{
	MRES_UNSET = 0,
	MRES_IGNORED,	// plugin didn't take any action
	MRES_HANDLED,	// plugin did something, but real function should still be called
	MRES_OVERRIDE,	// call real function, but use my return value
	MRES_SUPERCEDE, // skip real function; use my return value
} META_RES;

typedef struct meta_globals_s
{
	META_RES mres;		// writable; plugin's return flag
	META_RES prev_mres; // readable; return flag of the previous plugin called
	META_RES status;	// readable; "highest" return flag so far
	void *orig_ret;		// readable; return value from "real" function
	void *override_ret; // readable; return value from overriding/superceding plugin
} meta_globals_t;

typedef struct
{
	DLL_FUNCTIONS *dllapi_table;
	NEW_DLL_FUNCTIONS *newapi_table;
} gamedll_funcs_t;

enginefuncs_t g_engfuncs;
globalvars_t *gpGlobals;

C_DLLEXPORT int Meta_Query(const char *interfaceVersion,
						   plugin_info_t **plinfo,
						   mutil_funcs_t *pMetaUtilFuncs);
typedef int (*META_QUERY_FN)(const char *interfaceVersion,
							 plugin_info_t **plinfo,
							 mutil_funcs_t *pMetaUtilFuncs);

C_DLLEXPORT int Meta_Attach(PLUG_LOADTIME now,
							META_FUNCTIONS *pFunctionTable,
							meta_globals_t *pMGlobals,
							gamedll_funcs_t *pGamedllFuncs);
typedef int (*META_ATTACH_FN)(PLUG_LOADTIME now,
							  META_FUNCTIONS *pFunctionTable,
							  meta_globals_t *pMGlobals,
							  gamedll_funcs_t *pGamedllFuncs);

C_DLLEXPORT int Meta_Detach(PLUG_LOADTIME now, PL_UNLOAD_REASON reason);
typedef int (*META_DETACH_FN)(PLUG_LOADTIME now, PL_UNLOAD_REASON reason);

// #include "hlsdk/cl_dll/wrect.h"
// typedef float vec_t;
// #include "hlsdk/common/port.h"
// #include "hlsdk/dlls/vector.h"
// #include "hlsdk/common/mathlib.h"
// #include "hlsdk/cl_dll/cl_dll.h"
// #include "hlsdk/cl_dll/cl_util.h"
// #include "hlsdk/engine/cdll_int.h"
// #include "hlsdk/dlls/extdll.h"
// #include "hlsdk/dlls/util.h"
// #include "hlsdk/cl_dll/ammo.h"
// #include "hlsdk/cl_dll/ammohistory.h"
// #include "hlsdk/cl_dll/bench.h"
// #include "hlsdk/cl_dll/camera.h"
// #include "hlsdk/cl_dll/com_weapons.h"
// #include "hlsdk/cl_dll/demo.h"
// #include "hlsdk/cl_dll/ev_hldm.h"
// #include "hlsdk/cl_dll/eventscripts.h"
// #include "hlsdk/cl_dll/Exports.h"
// #include "hlsdk/cl_dll/GameStudioModelRenderer.h"
// #include "hlsdk/cl_dll/GameStudioModelRenderer_Sample.h"
// #include "hlsdk/cl_dll/global_consts.h"
// #include "hlsdk/cl_dll/health.h"
// #include "hlsdk/cl_dll/hud.h"
// #include "hlsdk/cl_dll/hud_benchtrace.h"
// #include "hlsdk/cl_dll/hud_iface.h"
// #include "hlsdk/cl_dll/hud_servers.h"
// #include "hlsdk/cl_dll/hud_servers_priv.h"
// #include "hlsdk/cl_dll/hud_spectator.h"
// #include "hlsdk/cl_dll/in_defs.h"
// #include "hlsdk/cl_dll/interpolation.h"
// #include "hlsdk/cl_dll/kbutton.h"
// #include "hlsdk/cl_dll/overview.h"
// #include "hlsdk/cl_dll/player_info.h"
// #include "hlsdk/cl_dll/studio_util.h"
// #include "hlsdk/cl_dll/StudioModelRenderer.h"
// #include "hlsdk/cl_dll/tf_defs.h"
// #include "hlsdk/cl_dll/tri.h"
// #include "hlsdk/cl_dll/util_vector.h"
// #include "hlsdk/cl_dll/vgui_ConsolePanel.h"
// #include "hlsdk/cl_dll/vgui_ControlConfigPanel.h"
// #include "hlsdk/cl_dll/vgui_int.h"
// #include "hlsdk/cl_dll/vgui_SchemeManager.h"
// #include "hlsdk/cl_dll/vgui_ScorePanel.h"
// #include "hlsdk/cl_dll/vgui_ServerBrowser.h"
// #include "hlsdk/cl_dll/vgui_SpectatorPanel.h"
// #include "hlsdk/cl_dll/vgui_TeamFortressViewport.h"
// #include "hlsdk/cl_dll/view.h"
// #include "hlsdk/cl_dll/voice_status.h"

// #include "hlsdk/common/beamdef.h"
// #include "hlsdk/common/cl_entity.h"
// #include "hlsdk/common/com_model.h"
// #include "hlsdk/common/con_nprint.h"
// #include "hlsdk/common/const.h"
// #include "hlsdk/common/crc.h"
// #include "hlsdk/common/cvardef.h"
// #include "hlsdk/common/demo_api.h"
// #include "hlsdk/common/director_cmds.h"
// #include "hlsdk/common/dlight.h"
// #include "hlsdk/common/dll_state.h"
// #include "hlsdk/common/entity_state.h"
// #include "hlsdk/common/entity_types.h"
// #include "hlsdk/common/enums.h"
// #include "hlsdk/common/event_api.h"
// #include "hlsdk/common/event_args.h"
// #include "hlsdk/common/event_flags.h"
// #include "hlsdk/common/hltv.h"
// #include "hlsdk/common/in_buttons.h"
// #include "hlsdk/common/interface.h"
// #include "hlsdk/common/ivoicetweak.h"
// #include "hlsdk/common/net_api.h"
// #include "hlsdk/common/netadr.h"
// #include "hlsdk/common/nowin.h"
// #include "hlsdk/common/parsemsg.h"
// #include "hlsdk/common/particledef.h"
// #include "hlsdk/common/pmtrace.h"
// #include "hlsdk/common/qfont.h"
// #include "hlsdk/common/r_efx.h"
// #include "hlsdk/common/r_studioint.h"
// #include "hlsdk/common/ref_params.h"
// #include "hlsdk/common/screenfade.h"
// #include "hlsdk/common/Sequence.h"
// #include "hlsdk/common/studio_event.h"
// #include "hlsdk/common/triangleapi.h"
// #include "hlsdk/common/usercmd.h"
// #include "hlsdk/common/weaponinfo.h"

// #include "hlsdk/dlls/activity.h"
// #include "hlsdk/dlls/activitymap.h"
// #include "hlsdk/dlls/animation.h"
// #include "hlsdk/dlls/basemonster.h"
// #include "hlsdk/dlls/cbase.h"
// #include "hlsdk/dlls/cdll_dll.h"
// #include "hlsdk/dlls/client.h"
// #include "hlsdk/dlls/decals.h"
// #include "hlsdk/dlls/defaultai.h"
// #include "hlsdk/dlls/doors.h"
// #include "hlsdk/dlls/effects.h"
// #include "hlsdk/dlls/enginecallback.h"
// #include "hlsdk/dlls/explode.h"
// #include "hlsdk/dlls/flyingmonster.h"
// #include "hlsdk/dlls/func_break.h"
// #include "hlsdk/dlls/game.h"
// #include "hlsdk/dlls/gamerules.h"
// #include "hlsdk/dlls/hornet.h"
// #include "hlsdk/dlls/items.h"
// #include "hlsdk/dlls/maprules.h"
// #include "hlsdk/dlls/monsterevent.h"
// #include "hlsdk/dlls/monsters.h"
// #include "hlsdk/dlls/nodes.h"
// #include "hlsdk/dlls/plane.h"
// #include "hlsdk/dlls/player.h"
// #include "hlsdk/dlls/saverestore.h"
// #include "hlsdk/dlls/schedule.h"
// #include "hlsdk/dlls/scripted.h"
// #include "hlsdk/dlls/scriptevent.h"
// #include "hlsdk/dlls/skill.h"
// #include "hlsdk/dlls/soundent.h"
// #include "hlsdk/dlls/spectator.h"
// #include "hlsdk/dlls/squad.h"
// #include "hlsdk/dlls/squadmonster.h"
// #include "hlsdk/dlls/talkmonster.h"
// #include "hlsdk/dlls/teamplay_gamerules.h"
// #include "hlsdk/dlls/trains.h"
// #include "hlsdk/dlls/weapons.h"
// #include "hlsdk/dlls/wxdebug.h"

// #include "hlsdk/engine/anorms.h"
// #include "hlsdk/engine/APIProxy.h"
// #include "hlsdk/engine/custom.h"
// #include "hlsdk/engine/customentity.h"
// #include "hlsdk/engine/edict.h"
// #include "hlsdk/engine/eiface.h"
// #include "hlsdk/engine/progdefs.h"
// #include "hlsdk/engine/progs.h"
// #include "hlsdk/engine/shake.h"
// #include "hlsdk/engine/studio.h"

// #include "hlsdk/game_shared/bitvec.h"
// #include "hlsdk/game_shared/GameEvent.h"
// #include "hlsdk/game_shared/perf_counter.h"
// #include "hlsdk/game_shared/shared_util.h"
// #include "hlsdk/game_shared/simple_checksum.h"
// #include "hlsdk/game_shared/steam_util.h"
// #include "hlsdk/game_shared/vgui_checkbutton2.h"
// #include "hlsdk/game_shared/vgui_defaultinputsignal.h"
// #include "hlsdk/game_shared/vgui_grid.h"
// #include "hlsdk/game_shared/vgui_helpers.h"
// #include "hlsdk/game_shared/vgui_listbox.h"
// #include "hlsdk/game_shared/vgui_loadtga.h"
// #include "hlsdk/game_shared/vgui_scrollbar2.h"
// #include "hlsdk/game_shared/vgui_slider2.h"
// #include "hlsdk/game_shared/voice_banmgr.h"
// #include "hlsdk/game_shared/voice_common.h"
// #include "hlsdk/game_shared/voice_gamemgr.h"
// #include "hlsdk/game_shared/voice_status.h"
// #include "hlsdk/game_shared/voice_status_hud.h"
// #include "hlsdk/game_shared/voice_vgui_tweakdlg.h"

// #include "hlsdk/public/archtypes.h"
// #include "hlsdk/public/FileSystem.h"
// #include "hlsdk/public/interface.h"
// #include "hlsdk/public/keydefs.h"
// #include "hlsdk/public/particleman.h"
// #include "hlsdk/public/pman_particlemem.h"
// #include "hlsdk/public/pman_triangleffect.h"
// #include "hlsdk/public/cl_dll/IGameClientExports.h"
// #include "hlsdk/public/steam/steamtypes.h"

// #include "hlsdk/pm_shared/pm_debug.h"
// #include "hlsdk/pm_shared/pm_defs.h"
// #include "hlsdk/pm_shared/pm_info.h"
// #include "hlsdk/pm_shared/pm_materials.h"
// #include "hlsdk/pm_shared/pm_movevars.h"
// #include "hlsdk/pm_shared/pm_shared.h"

// #include "metamod-hl1/metamod/api_info.h"
// #include "metamod-hl1/metamod/commands_meta.h"
// #include "metamod-hl1/metamod/conf_meta.h"
// #include "metamod-hl1/metamod/dllapi.h"
// #include "metamod-hl1/metamod/engine_api.h"
// #include "metamod-hl1/metamod/engine_t.h"
// #include "metamod-hl1/metamod/enginecallbacks.h"
// #include "metamod-hl1/metamod/engineinfo.h"
// #include "metamod-hl1/metamod/game_support.h"
// #include "metamod-hl1/metamod/games.h"
// #include "metamod-hl1/metamod/h_export.h"
// #include "metamod-hl1/metamod/info_name.h"
// #include "metamod-hl1/metamod/linkent.h"
// #include "metamod-hl1/metamod/log_meta.h"
// #include "metamod-hl1/metamod/meta_api.h"
// #include "metamod-hl1/metamod/meta_eiface.h"
// #include "metamod-hl1/metamod/metamod.h"
// #include "metamod-hl1/metamod/mhook.h"
// #include "metamod-hl1/metamod/mlist.h"
// #include "metamod-hl1/metamod/mplayer.h"
// #include "metamod-hl1/metamod/mplugin.h"
// #include "metamod-hl1/metamod/mqueue.h"
// #include "metamod-hl1/metamod/mreg.h"
// #include "metamod-hl1/metamod/mutil.h"
// #include "metamod-hl1/metamod/osdep.h"
// #include "metamod-hl1/metamod/plinfo.h"
// #include "metamod-hl1/metamod/reg_support.h"
// #include "metamod-hl1/metamod/sdk_util.h"
// #include "metamod-hl1/metamod/studioapi.h"
// #include "metamod-hl1/metamod/support_meta.h"
// #include "metamod-hl1/metamod/thread_logparse.h"
// #include "metamod-hl1/metamod/tqueue.h"
// #include "metamod-hl1/metamod/types_meta.h"
// #include "metamod-hl1/metamod/vdate.h"
// #include "metamod-hl1/metamod/vers_meta.h"
